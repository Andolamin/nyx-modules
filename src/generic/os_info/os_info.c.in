/* @@@LICENSE
*
*      Copyright (c) 2013 LG Electronics
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* LICENSE@@@ */

/*
*******************************************************************
* @file os_info.c
*
* @brief The OS_INFO module implementation.
*******************************************************************
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <nyx/nyx_module.h>
#include <nyx/module/nyx_utils.h>

static const char *read_core_os_release = "lsb_release -sr";
static const char *read_core_os_name = "lsb_release -si";
static const char *read_core_os_release_codename = "lsb_release -sc";

NYX_DECLARE_MODULE(NYX_DEVICE_OS_INFO, "OSInfo");

static const char* read_lsb_release(const char *command)
{
	FILE *fp = NULL;
	int temp_size = 0;
	char* retString = NULL; //has to be NULL for getline to work properly

	/* Open the command for reading. */
	fp = popen(command, "r");

	if (NULL != fp)
	{
		if( -1 == getline(&retString, &temp_size, fp))
			retString = ""; //return empty string if error
		/* close */
		pclose(fp);
	}
	else
		retString = ""; //return empty string if error

	return retString;
}

nyx_error_t nyx_module_open(nyx_instance_t i, nyx_device_t** d)
{
	if(NULL == d)
		return NYX_ERROR_INVALID_VALUE;

	*d = NULL;
	nyx_device_t* device = (nyx_device_t*)calloc(1, sizeof(nyx_device_t));

	if (NULL != device)
	{
		nyx_module_register_method(i, device, NYX_OS_INFO_QUERY_MODULE_METHOD, "os_info_query");

		*d = device;

		return NYX_ERROR_NONE;
	}
	else
	{
		return NYX_ERROR_OUT_OF_MEMORY;
	}
}

nyx_error_t nyx_module_close(nyx_device_handle_t d)
{
	if(NULL == d)
		return NYX_ERROR_INVALID_HANDLE;

	nyx_device_t* os_info = (nyx_device_t*)d;

	free(os_info);

	return NYX_ERROR_NONE;
}

nyx_error_t os_info_query(nyx_device_handle_t d, nyx_os_info_query_t query, const char** dest)
{
	if(NULL == d)
	{
		return NYX_ERROR_INVALID_HANDLE;
	}
	else
	{
		// return an empty string if there's an error
		*dest = "";

		switch (query)
		{
			case NYX_OS_INFO_WEBOS_BUILD:
			case NYX_OS_INFO_WEBOS_RELEASE_CODENAME:
			case NYX_OS_INFO_WEBOS_IMAGENAME:
			case NYX_OS_INFO_WEBOS_API_VERSION:
			case NYX_OS_INFO_CORE_OS_KERNEL_VERSION:    // Implemented later
			case NYX_OS_INFO_CORE_OS_KERNEL_CONFIG:     // Implemented later
				return NYX_ERROR_NOT_IMPLEMENTED;

			case NYX_OS_INFO_WEBOS_NAME:
				*dest = "@DISTRO_NAME@";
				return NYX_ERROR_NONE;

			case NYX_OS_INFO_WEBOS_RELEASE:
				*dest = "@DISTRO_VERSION@";
				return NYX_ERROR_NONE;

			case NYX_OS_INFO_WEBOS_PRERELEASE:          // change this after proper
			                                            // variable is defined
				*dest = "devel";
				return NYX_ERROR_NONE;

			case NYX_OS_INFO_CORE_OS_NAME:
				*dest = read_lsb_release(read_core_os_name);
				return NYX_ERROR_NONE;

			case NYX_OS_INFO_CORE_OS_RELEASE:
				*dest = read_lsb_release(read_core_os_release);
				return NYX_ERROR_NONE;

			case NYX_OS_INFO_CORE_OS_RELEASE_CODENAME:
				*dest = read_lsb_release(read_core_os_release_codename);
				return NYX_ERROR_NONE;

			default:
				return NYX_ERROR_INVALID_VALUE;
		}
	}
}
